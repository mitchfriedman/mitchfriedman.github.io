<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Mitchell Friedman</title>
    <link>/tags/go/</link>
    <description>Recent content in go on Mitchell Friedman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Jun 2019 13:32:44 +0100</lastBuildDate>
    
	<atom:link href="/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Load Testing For Everyone</title>
      <link>/blog/load-generator/</link>
      <pubDate>Sat, 08 Jun 2019 13:32:44 +0100</pubDate>
      
      <guid>/blog/load-generator/</guid>
      <description>What is load testing? From the wikipedia, we have one definition of:
 Load testing is the process of putting demand on a system and measuring its response.
 This is a pretty straight forward and simple way of putting it, but I like it - throw some load at a service and see what happens. Specifically, when we&amp;rsquo;re talking about load testing HTTP services, some of the things we are looking for are;</description>
    </item>
    
    <item>
      <title>JSON Schema</title>
      <link>/blog/json-schema/</link>
      <pubDate>Sun, 19 May 2019 16:20:00 +0100</pubDate>
      
      <guid>/blog/json-schema/</guid>
      <description>JSON Schema + Go + APIs API Validation After working on a few Go HTTP servers (particularly JSON) i&amp;rsquo;ve noticed a few different patterns for validating API bodies.
JSON is an unstructured language that is commonly used for micro-services to communicate with each other. One of the big advantages to using something like JSON is that either the server or the client the transport data without any prior syncronization. On the other hand, one of the big pitfalls to using something like JSON is that either the server or the client can change the transport data without any prior syncronization.</description>
    </item>
    
  </channel>
</rss>